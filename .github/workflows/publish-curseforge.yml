name: Publish to CurseForge

on:
  release:
    types: [published]

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      #
      # Download ZIP file uploaded manually to the GitHub Release
      #
      - name: Download ZIP from Release Assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Searching for release assets‚Ä¶"

          RELEASE_DATA=$(curl -s \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/releases/latest)

          ASSET_URL=$(echo "$RELEASE_DATA" | grep -oP '"url": "\K[^"]+' | grep '/assets/' | head -n 1)

          if [ -z "$ASSET_URL" ]; then
            echo "‚ùå No ZIP file found in release assets!"
            exit 1
          fi

          echo "üì¶ Found ZIP asset: $ASSET_URL"

          curl -L \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/octet-stream" \
            "$ASSET_URL" \
            -o decorations-plus.zip

          echo "‚úÖ ZIP downloaded: decorations-plus.zip"

      #
      # Extract release metadata
      #
      - name: Prepare Release Info
        id: info
        run: |
          echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          echo "is_prerelease=${{ github.event.release.prerelease }}" >> $GITHUB_OUTPUT

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "${{ github.event.release.body }}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      #
      # Upload to CurseForge
      #
      - name: Upload to CurseForge
        env:
          CURSEFORGE_TOKEN: ${{ secrets.CURSEFORGE_TOKEN }}
          PROJECT_ID: 1356841
          RELEASE_TAG: ${{ steps.info.outputs.tag }}
          RELEASE_BODY: ${{ steps.info.outputs.body }}
          IS_PRERELEASE: ${{ steps.info.outputs.is_prerelease }}
        run: |
          echo "üìÑ Release tag: $RELEASE_TAG"
          echo "üìò Pre-release: $IS_PRERELEASE"

          #
          # Extract version list from release notes comment
          #
          VERSIONS=$(echo "$RELEASE_BODY" | sed -n 's/.*<!-- minecraft-versions: \(.*\) -->.*/\1/p' | tr -d "\r")

          if [ -z "$VERSIONS" ]; then
            echo "‚ùå No minecraft-versions comment found!"
            exit 1
          fi

          echo "üéØ Minecraft versions requested: $VERSIONS"

          #
          # Fetch CurseForge's full game versions list
          #
          GAME_VERSIONS=$(curl -s -H "X-Api-Token: $CURSEFORGE_TOKEN" \
            "https://minecraft.curseforge.com/api/game/versions")

          #
          # Use Node.js to filter valid MC version IDs via STDIN
          #
          export VERSIONS="$VERSIONS"

          VERSION_IDS=$(printf "%s" "$GAME_VERSIONS" | node <<'EOF'
          const fs = require("fs");

          // Read the FULL JSON from STDIN (safe, not truncated)
          const all = JSON.parse(fs.readFileSync(0, "utf8"));

          // Read version list
          const wanted = process.env.VERSIONS.split(",").map(v => v.trim());

          // Filter ONLY real MC versions
          const matches = all.filter(v =>
            wanted.includes(v.name) &&
            v.gameVersionStatus === 1 &&
            v.versionType === "release" &&
            v.gameVersionTypeID === null
          );

          console.log(JSON.stringify(matches.map(v => v.id)));
          EOF
          )

          echo "üî• Valid CurseForge IDs: $VERSION_IDS"

          if [ "$VERSION_IDS" = "[]" ]; then
            echo "‚ùå No valid CurseForge version IDs found!"
            exit 1
          fi

          #
          # Determine release type
          #
          RELEASE_TYPE="release"
          if [[ "$RELEASE_TAG" == *"beta"* ]] || [[ "$IS_PRERELEASE" == "true" ]]; then
            RELEASE_TYPE="beta"
          elif [[ "$RELEASE_TAG" == *"alpha"* ]]; then
            RELEASE_TYPE="alpha"
          fi

          echo "üöÄ Release type: $RELEASE_TYPE"

          #
          # Build metadata JSON using Node
          #
          export VERSION_IDS="$VERSION_IDS"
          export RELEASE_TYPE="$RELEASE_TYPE"

          METADATA=$(node <<'EOF'
          const data = {
            changelog: process.env.RELEASE_BODY,
            changelogType: "markdown",
            displayName: "Decorations Plus " + process.env.RELEASE_TAG,
            gameVersions: JSON.parse(process.env.VERSION_IDS),
            releaseType: process.env.RELEASE_TYPE
          };
          console.log(JSON.stringify(data));
          EOF
          )

          echo "üìù Final metadata:"
          echo "$METADATA"

          #
          # Upload to CurseForge
          #
          echo "üì§ Uploading to CurseForge‚Ä¶"

          RESPONSE=$(curl -X POST \
            "https://minecraft.curseforge.com/api/projects/${PROJECT_ID}/upload-file" \
            -H "X-Api-Token: ${CURSEFORGE_TOKEN}" \
            -F "metadata=$METADATA;type=application/json" \
            -F "file=@decorations-plus.zip" \
            -w "\nHTTP_STATUS:%{http_code}")

          HTTP_STATUS=$(echo "$RESPONSE" | grep -oP 'HTTP_STATUS:\K\d+')
          BODY=$(echo "$RESPONSE" | sed 's/HTTP_STATUS:[0-9]*//g')

          echo "üì° Response: $BODY"
          echo "üìü HTTP Status: $HTTP_STATUS"

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            FILE_ID=$(node -e "console.log(JSON.parse(process.argv[1]).id || '')" "$BODY")
            echo "file_id=$FILE_ID" >> $GITHUB_ENV
            echo "‚úÖ Upload successful ‚Äî File ID: $FILE_ID"
          else
            echo "‚ùå Upload failed!"
            echo "$BODY"
            exit 1
          fi
